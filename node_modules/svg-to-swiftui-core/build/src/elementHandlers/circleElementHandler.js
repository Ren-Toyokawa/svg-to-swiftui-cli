import { clampNormalisedSizeProduct, normaliseRectValues, stringifyRectValues, } from '../utils';
export default function handleCircleElement(element, options) {
    // TODO: Add styles support
    // const style = {
    //   ...options.parentStyle,
    //   ...extractStyle(element),
    // };
    var props = element.properties;
    if (props) {
        var circleProps = props;
        // Check if required properties are provided.
        if (!circleProps.cx || !circleProps.cy || !circleProps.r) {
            throw new Error('Circle element has to contain cx, cy, and r properties!');
        }
        // Parse numbers from the striings.
        var cx = parseFloat(circleProps.cx);
        var cy = parseFloat(circleProps.cy);
        var r = parseFloat(circleProps.r);
        // Convert center-radius to bounding box.
        var x = cx - r;
        var y = cy - r;
        var width = r * 2;
        var height = r * 2;
        // Normalise all values to be based on fraction of width/height.
        var normalisedRect = normaliseRectValues({ x: x, y: y, width: width, height: height }, options.viewBox);
        // Stringify values to the fixed precision point.
        var SR = stringifyRectValues(normalisedRect, options.precision);
        // Append the width and height multipliers after normalisation.
        var strX = clampNormalisedSizeProduct(SR.x, 'width');
        var strY = clampNormalisedSizeProduct(SR.y, 'height');
        var strWidth = clampNormalisedSizeProduct(SR.width, 'width');
        var strHeight = clampNormalisedSizeProduct(SR.height, 'height');
        // Generate SwiftUI string.
        var CGRect = "CGRect(x: " + strX + ", y: " + strY + ", width: " + strWidth + ", height: " + strHeight + ")";
        return ["path.addEllipse(in: " + CGRect + ")"];
    }
    else {
        throw new Error('Circle element has to some properties');
    }
}
//# sourceMappingURL=circleElementHandler.js.map