var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { SVGPathData } from 'svg-pathdata';
import { generateMoveToSwift } from './moveToGenerator';
import { generateLineToSwift } from './lineToGenerator';
import { generateClosePathSwift } from './closePathGenerator';
import { generateCubicCurveSwift } from './cubicCurveGenerator';
import { generateQuadCurveSwift } from './quadCurveGenerator';
/**
 * Converts SVG Path element to SwiftUI path string.
 * @param element SVG Path Element
 * @param options Transpiler options
 */
export default function handlePathElement(element, options) {
    var properties = element.properties;
    if (properties) {
        var props = properties;
        if (!props.d) {
            throw new Error('Parameter `d` has to be provided on the <path> element!');
        }
        options.lastPathId++;
        var pathData = new SVGPathData(props.d).toAbs();
        return convertPathToSwift(pathData.commands, options);
    }
    else {
        throw new Error('Path element does not have any properties!');
    }
}
/**
 * Converts a list of `SVGCommand`s to SwiftUI Path
 * @param data Path data if SVGCommand[] type.
 * @param options Transpiler options
 */
var convertPathToSwift = function (data, options) {
    var swiftAccumulator = [];
    for (var i = 0; i < data.length; i++) {
        var el = data[i];
        // Handle data depending on command type.
        switch (el.type) {
            // Command M
            case SVGPathData.MOVE_TO: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var type = el.type, relative = el.relative, d = __rest(el, ["type", "relative"]);
                swiftAccumulator.push.apply(swiftAccumulator, generateMoveToSwift(d, options));
                break;
            }
            // Command L
            case SVGPathData.LINE_TO: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var type = el.type, relative = el.relative, d = __rest(el, ["type", "relative"]);
                swiftAccumulator.push.apply(swiftAccumulator, generateLineToSwift(d, options));
                break;
            }
            // Command H
            case SVGPathData.HORIZ_LINE_TO: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var type = el.type, relative = el.relative, d = __rest(el, ["type", "relative"]);
                var y = 0;
                for (var li = i - 1; li >= 0; li--) {
                    var prevElement = data[li];
                    if (prevElement.type === SVGPathData.MOVE_TO ||
                        prevElement.type === SVGPathData.LINE_TO ||
                        prevElement.type === SVGPathData.VERT_LINE_TO ||
                        prevElement.type === SVGPathData.CURVE_TO ||
                        prevElement.type === SVGPathData.SMOOTH_CURVE_TO ||
                        prevElement.type === SVGPathData.QUAD_TO ||
                        prevElement.type === SVGPathData.SMOOTH_QUAD_TO) {
                        y = prevElement.y;
                        break;
                    }
                    else if (prevElement.type === SVGPathData.HORIZ_LINE_TO) {
                        continue;
                    }
                    else {
                        break;
                    }
                }
                swiftAccumulator.push.apply(swiftAccumulator, generateLineToSwift({ x: d.x, y: y }, options));
                break;
            }
            // Command V
            case SVGPathData.VERT_LINE_TO: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var type = el.type, relative = el.relative, d = __rest(el, ["type", "relative"]);
                var x = 0;
                // Go backwards until a command with x value is fonud.
                for (var li = i - 1; li >= 0; li--) {
                    var prevElement = data[li];
                    if (prevElement.type === SVGPathData.MOVE_TO ||
                        prevElement.type === SVGPathData.LINE_TO ||
                        prevElement.type === SVGPathData.HORIZ_LINE_TO ||
                        prevElement.type === SVGPathData.CURVE_TO ||
                        prevElement.type === SVGPathData.SMOOTH_CURVE_TO ||
                        prevElement.type === SVGPathData.QUAD_TO ||
                        prevElement.type === SVGPathData.SMOOTH_QUAD_TO) {
                        x = prevElement.x;
                        break;
                    }
                    else if (prevElement.type === SVGPathData.VERT_LINE_TO) {
                        continue;
                    }
                    else {
                        break;
                    }
                }
                swiftAccumulator.push.apply(swiftAccumulator, generateLineToSwift({ x: x, y: d.y }, options));
                break;
            }
            // Command Z
            case SVGPathData.CLOSE_PATH: {
                swiftAccumulator.push.apply(swiftAccumulator, generateClosePathSwift(null, options));
                break;
            }
            // Command Q
            case SVGPathData.QUAD_TO: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var type = el.type, relative = el.relative, d = __rest(el, ["type", "relative"]);
                swiftAccumulator.push.apply(swiftAccumulator, generateQuadCurveSwift(d, options));
                break;
            }
            // Command T
            case SVGPathData.SMOOTH_QUAD_TO: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var type = el.type, relative = el.relative, d = __rest(el, ["type", "relative"]);
                var prevElement = data[i - 1];
                // Setup first control point
                var x1 = d.x;
                var y1 = d.y;
                if (prevElement.type === SVGPathData.QUAD_TO) {
                    x1 = prevElement.x + (prevElement.x - prevElement.x1);
                    y1 = prevElement.y + (prevElement.y - prevElement.y1);
                }
                swiftAccumulator.push.apply(swiftAccumulator, generateQuadCurveSwift(__assign(__assign({}, d), { x1: x1, y1: y1 }), options));
                break;
            }
            // Command C
            case SVGPathData.CURVE_TO: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var type = el.type, relative = el.relative, d = __rest(el, ["type", "relative"]);
                swiftAccumulator.push.apply(swiftAccumulator, generateCubicCurveSwift(d, options));
                break;
            }
            // Command S
            case SVGPathData.SMOOTH_CURVE_TO: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var type = el.type, relative = el.relative, d = __rest(el, ["type", "relative"]);
                var prevElement = data[i - 1];
                // Setup first control point
                var x1 = d.x;
                var y1 = d.y;
                if (prevElement.type === SVGPathData.CURVE_TO ||
                    prevElement.type === SVGPathData.SMOOTH_CURVE_TO) {
                    x1 = prevElement.x + (prevElement.x - prevElement.x2);
                    y1 = prevElement.y + (prevElement.y - prevElement.y2);
                }
                var swiftLines = generateCubicCurveSwift(__assign(__assign({}, d), { x1: x1, y1: y1 }), options);
                swiftAccumulator.push.apply(swiftAccumulator, swiftLines);
                break;
            }
            // Command A
            case SVGPathData.ARC: {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var type = el.type, relative = el.relative, d = __rest(el, ["type", "relative"]);
                // TODO: Implement this commend
                console.error('Arc is not supported yet');
                break;
            }
        }
    }
    return swiftAccumulator;
};
//# sourceMappingURL=index.js.map